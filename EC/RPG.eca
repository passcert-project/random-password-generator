require import AllCore Distr List UpdateList.

type char = int.
type password = int list.
type charSet = int list.
type policy = {length : int;
               lowercaseMin : int;
               lowercaseMax : int;
               uppercaseMin : int;
               uppercaseMax : int;
               numbersMin : int;
               numbersMax : int;
               specialMin : int;
               specialMax : int
}.

lemma char_in_concat2 (x:char) (set1 set2:charSet) :
  x \in (set1 ++ set2) =>
  x \in set1 \/ x \in set2.
proof.
exact mem_cat.
qed.

lemma char_in_concat3 (x:char) (set1 set2 set3:charSet) :
  x \in (set1 ++ set2 ++ set3) =>
  x \in set1 \/ x \in set2 \/ x \in set3.
proof.
smt(mem_cat).
qed.

lemma char_in_concat4 (x:char) (set1 set2 set3 set4:charSet) :
  x \in (set1 ++ set2 ++ set3 ++ set4) =>
  x \in set1 \/ x \in set2 \/ x \in set3 \/ x \in set4.
proof.
smt.
qed.


(* disjoint props *)
lemma disjoint_symmetry (set1 set2:charSet) :
  (forall (x : char), x \in set1 => !(x \in set2)) <=>
  (forall (x : char), x \in set2 => !(x \in set1)).
proof.
smt.
qed.

lemma disjoint_concat (set1 set2 set3:charSet) :
  (forall x, x \in set1 => ! (x \in set2)) =>
  (forall x, x \in set1 => ! (x \in set3)) =>
  forall x, x \in set1 => ! (x \in set2 ++ set3).
proof.
move => h1 h2 x h3.
have eq_not_mem: (!(x \in set2 ++ set3)) = !((mem set2 x) \/ (mem set3 x)).
  smt.
rewrite eq_not_mem.
rewrite negb_or.
split.
- apply h1. assumption.
- apply h2. assumption.
qed.


(* all props *)
lemma charset_all (set:charSet) :
  all (mem set) set.
proof.
smt.
qed.

lemma charset_all_concat (set1 set2:charSet) :
  all (mem (set1 ++ set2)) set1.
proof.
smt.
qed.

lemma charset_concat_all (set1 set2 set3:charSet) :
  all (mem (set1 ++ set3)) set2 =>
  (forall (x : char), x \in set2 => !(x \in set3)) =>
  all (mem set1) set2.
proof.
smt.
qed.

lemma charset_disjoint_notall (set1 set2:charSet) :
  0 < size set1 =>
  0 < size set2 =>
  (forall (x : char), x \in set1 => ! (x \in set2)) =>
  !(all (mem set1) set2) /\ !(all (mem set2) set1).
proof. 
case set1.
- trivial.
- case set2.
  + trivial.
  + move => x2 l2 x1 l1 h1 h2 h3.
    split.
    * smt.
    * have aux : forall (x : char), x \in x2 :: l2 => ! (x \in x1 :: l1).
      - by apply disjoint_symmetry.
      smt.        
qed.


(* has props *)
lemma charset_has (set:charSet) :
  0 < size set =>
  has (mem set) set.
proof.
case set.
- trivial.
- trivial.
qed.

lemma charset_has_concat (set1 set2:charSet) :
  0 < size set1 =>
  has (mem (set1 ++ set2)) set1.
proof.
smt.
qed.

lemma charset_disjoint_hasnot (set1 set2:charSet) :
  (forall (x : char), x \in set1 => ! (x \in set2)) =>
  !(has (mem set2) set1) (*/\ !(has (mem set1) set2)*).
proof.
move => h1.
rewrite hasPn.
move => x.
apply h1.
(*- rewrite hasPn.
  move => x.
  apply disjoint_symmetry.
  apply h1.*)
qed.


(* relations between all and has *)
lemma allP_hasP (p : 'a -> bool) s :
  0 < size s =>
  all p s => has p s.
proof.
case s.
- trivial.
- move => x l H.
  rewrite /all /=.
  move => [H1 H2].
  left.
  assumption.
qed.

lemma hasPn_allPn (p : 'a -> bool) s :
  0 < size s =>
  !has p s => !all p s.
proof.
case s.
- trivial.
- move => x l H.
  rewrite hasPn.
  rewrite allP. 
  move => H1.
  apply negb_forall.
  exists (x).
  have x_in_x_l: x \in x::l.
    trivial.
  apply H1 in x_in_x_l.
  simplify.
  assumption.
qed.


op setOccurrences (set:charSet) (pw:password) : int =
  with pw = []     => 0
  with pw = x :: s => if x \in set then 1 + setOccurrences set s
                                   else 0 + setOccurrences set s.

lemma setocc_empty_pw (set:charSet) :
  setOccurrences set [] = 0.
proof.
trivial.
qed.

lemma setocc_empty_set (pw:password) :
  setOccurrences [] pw = 0.
proof.
elim pw.
- trivial.
- move => x l.
  trivial.
qed.

lemma setocc_concat (set:charSet) (pw1 pw2:password) :
  setOccurrences set (pw1 ++ pw2) = setOccurrences set pw1 + setOccurrences set pw2.
proof.
elim pw1.
- rewrite cat0s.
  trivial.
- move => x l h1.
  case (x \in set).
  + move => -> /=. (*rewrite h2*) 
    smt.    
  + smt.
qed.


lemma setocc_insert_inset (set:charSet) (pw:password) (x:char) :
  x \in set =>
  setOccurrences set (pw ++ [x]) = (setOccurrences set pw) + 1.
proof.
smt.
qed.

lemma setocc_insert_notinset (set:charSet) (pw:password) (x:char) :
  !(x \in set) =>
  setOccurrences set (pw ++ [x]) = setOccurrences set pw.
proof.
move => ?.
case pw.
- smt.
- smt.
qed.


lemma setocc_take_drop (set:charSet) (pw:password) (n:int) :
  setOccurrences set (take n pw) + setOccurrences set (drop n pw) = setOccurrences set pw.
proof.
rewrite -setocc_concat.
rewrite cat_take_drop.
reflexivity.
qed.

lemma setocc_drop_plus1 (set:charSet) (pw:password) (n:int) (x:char) :
  nth x pw (n-1) \in set =>
  0 < n =>
  n < size pw =>
  0 < size pw =>
  setOccurrences set (drop (n+1) pw) = setOccurrences set (drop n pw) - 1.
proof.
case pw.
- trivial.
- move => ? ?.
  admit.
qed.

lemma setocc_update_inset (set:charSet) (pw:password) (x y:char) (n:int) :
  0 <= n =
  n < size pw =>
  x \in set =>
  nth y pw n \in set =>
  setOccurrences set (update x pw n) = setOccurrences set pw.
proof.
case pw.
- move => ? ? ?.
  rewrite /update.    
  simplify.
  smt.
- move => ? ?. admit.
qed.



lemma setoccurrences_update (set:charSet) (pw:password) (x:char) (i j:int) :
  0 < i =>
  j < i =>
  0 <= j =>
setOccurrences set (update (nth x pw (i - 1)) (update (nth x pw j) pw (i - 1)) j) =
setOccurrences set pw.
proof.
move => ? ? ?.
case pw.
- move => />.
  rewrite /update.
- admit.
admit.
qed.

lemma satisfies_eq (pwA pwB:password) (set:charSet):
  pwA = pwB =>
  setOccurrences set pwA = setOccurrences set pwB.
proof.
trivial.
qed.


op satisfiesMin (min:int) (set:charSet) (pw:password) : bool =
  min <= setOccurrences set pw.

op satisfiesMax (max:int) (set:charSet) (pw:password) : bool =
  setOccurrences set pw <= max.




(* Abstract type of a RPG *)
module type RPG_T = { 
  proc generate_password(policy:policy) : password
  proc get_lowercase() : charSet
  proc get_uppercase() : charSet
  proc get_numbers() : charSet
  proc get_special() : charSet
}.


(* Correctness definition for a RPG*)
module Correctness(RPG : RPG_T) = {


  proc main(policy:policy) : bool = {
  
    var pw : password;
    var lowercaseSet, uppercaseSet, numbersSet, specialSet : charSet;
    var lowercaseOcc, uppercaseOcc, numbersOcc, specialOcc : int;
    var satisfied : bool;

    if(policy.`length <= 200 /\
       0 < policy.`length /\ 
       0 <= policy.`lowercaseMin /\
       0 <= policy.`uppercaseMin /\
       0 <= policy.`numbersMin /\
       0 <= policy.`specialMin /\
       0 <= policy.`lowercaseMax /\
       0 <= policy.`uppercaseMax /\
       0 <= policy.`numbersMax /\
       0 <= policy.`specialMax /\
       policy.`lowercaseMin <= policy.`lowercaseMax /\
       policy.`uppercaseMin <= policy.`uppercaseMax /\
       policy.`numbersMin <= policy.`numbersMax /\
       policy.`specialMin <= policy.`specialMax /\
       policy.`lowercaseMin + policy.`uppercaseMin + policy.`numbersMin + policy.`specialMin
         <= policy.`length /\
       policy.`length <=
         policy.`lowercaseMax + policy.`uppercaseMax + policy.`numbersMax + policy.`specialMax) {

    lowercaseSet <- RPG.get_lowercase();
    uppercaseSet <- RPG.get_uppercase();
    numbersSet <- RPG.get_numbers();
    specialSet <- RPG.get_special();

    pw <@ RPG.generate_password(policy);
    
    satisfied <- size pw = policy.`length /\
                 satisfiesMin policy.`lowercaseMin lowercaseSet pw /\
                 satisfiesMax policy.`lowercaseMax lowercaseSet pw /\
                 satisfiesMin policy.`uppercaseMin uppercaseSet pw /\
                 satisfiesMax policy.`uppercaseMax uppercaseSet pw /\
                 satisfiesMin policy.`numbersMin numbersSet pw /\
                 satisfiesMax policy.`numbersMax numbersSet pw /\
                 satisfiesMin policy.`specialMin specialSet pw /\
                 satisfiesMax policy.`specialMax specialSet pw;
    }

    else {
      satisfied <- true;
    }


    
    return satisfied;

   }

}.
