require import AllCore Distr Dexcepted List UpdateList.
require (****) PasswordGenerationTh.

clone include PasswordGenerationTh.

(* Abstract type of an RPG *)
module type RPG_T = { 
  proc generate_password(policy:policy) : password option
}.


(*******************************)
(*         CORRECTNESS         *)
(*******************************)

op satisfiesLength (p:policy) (pw:password) : bool =
  size pw = p.`length.

op satisfiesSetBounds (min max:int) (set:charSet) (pw:password) : bool =
 min <= setOccurrences set pw <= max.

op satisfiesBounds (p:policy) (pw:password) : bool =
  p.`lowercaseMin <= setOccurrences lowercaseSet pw <= p.`lowercaseMax /\
  p.`uppercaseMin <= setOccurrences uppercaseSet pw <= p.`uppercaseMax /\
  p.`numbersMin <= setOccurrences numbersSet pw <= p.`numbersMax /\
  p.`specialMin <= setOccurrences specialSet pw <= p.`specialMax.



(* Correctness definition for an RPG *)
module Correctness(RPG : RPG_T) = {

  proc main(policy:policy) : bool = {
  
    var pw : password option;
    var satisfied : bool;

    pw <@ RPG.generate_password(policy);

    if(isPolicySatisfiable policy) {
    
      satisfied <- is_some pw /\
                   satisfiesLength policy (oget pw) /\
                   satisfiesBounds policy (oget pw);
    }
    else {
      satisfied <- is_none pw;
    }
    
    return satisfied;

   }

}.



(*******************************)
(*          SECURITY           *)
(*******************************)

(* Distribution over passwords *)
op dpassword : password distr.

axiom dpassword_ll : is_lossless dpassword.
axiom dpassword_uni : is_uniform dpassword.
axiom dpassword_fu : is_full dpassword.

(* Ideal RPG Oracle *)
module IdealRPG  = {

  proc generate_password(policy:policy) = {
    var pw;
    var out;
    
    if(isPolicySatisfiable policy) {
      pw <$ dpassword \ (fun pass => !(satisfiesLength policy pw) /\ !(satisfiesBounds policy pw));
      out <- Some pw;
    } else {
      out <- None;
    }

    return out;
  }

}.

(*module ModifiedRPG : Orcl = {


  proc rng(range:int) : int = {
    
    var value, maxValue : int;

    maxValue <- ((2^64) %/ range) * range - 1;

    value <$ [0 .. (2^64) - 1];

    while (maxValue < value) {
      value <$ [0 .. (2^64) - 1]; (* Random Bytes Generator *)
    }
    
    value <- (value %% range);
    
    return value;
    
  }

  
  proc permutation(pw:password) : password = {

    var i : int;
    var j : int;
    var aux : char;
    
    i <- size pw;
    
    while (0 < i) {
      j <@ rng(i);
      i <- i - 1;
      aux <- nth 0 pw i;
      pw <- update (nth 0 pw j) pw i;
      pw <- update aux pw j;
    }
    
    return pw;
 
  }

  proc generate_password(p:policy) = {
    var pw;

    pw <$ dpassword \ (fun pass => !(satisfiesLength p pw) /\ !(satisfiesBounds p pw));


    pw <- permutation(pw);

    return pw;
  }

}.


ction TEST.

declare module A:Adv.

lemma Ideal_eq_Modified :
  equiv [ IdealRPG.generate_password ~ ModifiedRPG.generate_password : 
            true ==> ={res} ].
proc.
seq 1 1 : (={pw}).
admitted.

section end.*)
